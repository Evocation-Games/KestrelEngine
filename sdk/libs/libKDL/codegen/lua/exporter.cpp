// Copyright (c) 2023 Tom Hancocks
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#include <libKDL/codegen/lua/exporter.hpp>
#include <libKDL/spec/types.hpp>
#include <libKDL/spec/decorators.hpp>
#include <libResource/definition/type/field.hpp>

// MARK: - Construction

kdl::codegen::lua::exporter::exporter(const resource::definition::type::instance *type, interpreter::scope *scope)
    : m_type_definition(type), m_api(kestrel_api::create(&m_generator)), m_scope(scope)
{}

// MARK: - Export Names

auto kdl::codegen::lua::exporter::determine_export_names() -> void
{
    for (const auto& field : m_type_definition->all_fields()) {
        for (auto i = 0; i < field.value_count(); ++i) {
            const auto& value = field.value_at(i);
            if (value.has_export_name()) {
                m_type.export_names.emplace(value.base_name(), value.export_name());
            }

            for (const auto& joined : value.joined_values()) {
                if (joined.has_export_name()) {
                    m_type.export_names.emplace(joined.base_name(), joined.export_name());
                }
            }
        }
    }
}

// MARK: - Code Production

auto kdl::codegen::lua::exporter::produce_header() -> void
{
    m_generator.add_comment("This code was auto generated by KDL.");
    m_generator.add_comment("Do not modify, as alterations will be automatically reverted.");
    m_generator.new_line();
}

auto kdl::codegen::lua::exporter::produce_class_boilerplate() -> void
{
    m_generator.add_comment(m_type_definition->name() + " Class Definition");
    m_type.klass_name = m_generator.symbol(m_type_definition->name());
    m_type.klass = m_generator.declare_class(m_type_definition->name());
    m_generator.new_line();

    auto resource_type_code_sym = m_generator.symbol("resourceTypeCode");
    m_type.type_code_func = m_generator.declare_static_function(false, resource_type_code_sym, m_type.klass);
    m_generator.begin_block();
    {
        m_generator.return_statement(m_generator.string(m_type_definition->code()));
    }
    m_generator.end_block();
    m_generator.new_line();
}

auto kdl::codegen::lua::exporter::produce_model_loader() -> void
{
    auto ref = m_generator.symbol("resourceReference");
    m_generator.add_comment(" Construction");
    m_generator.declare_static_function(false, m_generator.symbol("load"), m_type.klass, { ref });
    m_generator.begin_block();
    {
        m_generator.condition(m_generator.apply_not(ref));
        m_generator.begin_block();
        {
            m_generator.return_statement(m_generator.nil());
        }
        m_generator.end_block();
        m_generator.new_line();

        auto resource = m_generator.symbol("resource");
        auto data = m_generator.symbol("data");

        m_generator.local_assign(resource, m_generator.construct(m_type.klass));
        m_generator.local_assign(data, m_generator.call(m_api.load_helper_function, { resource, ref, m_generator.call(m_type.type_code_func) }));
        m_generator.new_line();

        m_generator.condition(m_generator.apply_not(data));
        m_generator.begin_block();
        {
            m_generator.return_statement(m_generator.nil());
        }
        m_generator.end_block();
        m_generator.new_line();

        prepare_template_read_calls(resource, data);
        prepare_template_read_calls(resource);
        produce_template_property_mapping(resource);

        m_generator.return_statement(resource);
    }
    m_generator.end_block();
}

auto kdl::codegen::lua::exporter::build_field_name(const resource::definition::type::field_value *field_value, std::int64_t field_number) -> ast::symbol *
{
    if (field_value->has_export_name()) {
        return m_generator.camel_case(field_value->export_name());
    }
    else if (field_number >= 0) {
        auto scope = m_scope->subscope();
        scope.add_variable("FieldNumber", field_number);
        return m_generator.camel_case(field_value->extended_name(scope));
    }
    else {
        return m_generator.camel_case(field_value->base_name());
    }
}

auto kdl::codegen::lua::exporter::field_for_binary_field(const resource::definition::binary_template::field *binary_field) -> resource::definition::type::field
{
    for (auto& field : m_type_definition->all_fields()) {
        std::int64_t lower = 1;
        std::int64_t upper = 1;

        if (field.repeatable().enabled()) {
            lower = field.repeatable().lower_bound();
            upper = field.repeatable().upper_bound();

            if (field.repeatable().has_count_field() && field.repeatable().count_field()->label() == binary_field->label()) {
                return field;
            }
        }

        for (auto n = lower; n < upper; ++n) {
            auto scope = m_scope->subscope();
            scope.add_variable("FieldNumber", n);

            for (auto i = 0; i < field.value_count(); ++i) {
                const auto& value = field.value_at(i);
                auto name = value.extended_name(scope);

                if (binary_field->label() == name) {
                    return field;
                }

                for (const auto& joined : value.joined_values()) {
                    auto joined_name = joined.extended_name(scope);
                    if (binary_field->label() == joined_name) {
                        return field;
                    }
                }
            }
        }
    }
    throw std::runtime_error("Binary field reference could not be found in field values");
}

auto kdl::codegen::lua::exporter::field_value_for_binary_field(const resource::definition::binary_template::field *binary_field) -> resource::definition::type::field_value
{
    for (auto& field : m_type_definition->all_fields()) {
        std::int64_t lower = 1;
        std::int64_t upper = 1;

        if (field.repeatable().enabled()) {
            lower = field.repeatable().lower_bound();
            upper = field.repeatable().upper_bound();
        }

        for (auto n = lower; n <= upper; ++n) {
            auto scope = m_scope->subscope();
            scope.add_variable("FieldNumber", n);

            for (auto i = 0; i < field.value_count(); ++i) {
                auto value = field.value_at(i);
                auto name = value.extended_name(scope);

                if (binary_field->label() == name) {
                    return value;
                }

                for (const auto& joined : value.joined_values()) {
                    auto joined_name = joined.extended_name(scope);
                    if (binary_field->label() == joined_name) {
                        return joined;
                    }
                }
            }
        }
    }
    throw std::runtime_error("Binary field reference could not be found in field values");
}

auto kdl::codegen::lua::exporter::prepare_template_read_calls(ast::symbol *resource, ast::symbol *data) -> void
{
    auto tmpl = m_type_definition->binary_template();

    // The first task for the resource reader is to produce all the read calls for the binary template fields.
    for (auto& field : m_type_definition->all_fields()) {
        if (field.repeatable().enabled() && field.repeatable().has_count_field()) {
            // Get the OCNT field for the count field, and add a reader for it.
            auto binary_field = field.repeatable().count_field();
            auto list_count = produce_read_call(binary_field, data);
            m_type.binary_fields.emplace(binary_field->label(), list_count);

            for (auto i = 0; i < field.value_count(); ++i) {
                const auto& value = field.value_at(i);
                binary_field = &tmpl->field_named(value.base_name());
                auto value_reader = produce_read_call(binary_field, &value, data);
                m_type.binary_fields.emplace(binary_field->label(), value_reader);

                if (value.has_joined_values()) {
                    for (const auto& joined : value.joined_values()) {
                        binary_field = &tmpl->field_named(joined.base_name());
                        value_reader = produce_read_call(binary_field, &joined, data);
                        m_type.binary_fields.emplace(binary_field->label(), value_reader);
                    }
                }
            }
        }
        else if (field.repeatable().enabled()) {
            for (std::int64_t i = field.repeatable().lower_bound(); i <= field.repeatable().upper_bound(); ++i) {
                auto scope = m_scope->subscope();
                scope.add_variable("FieldNumber", i);

                for (auto j = 0; j < field.value_count(); ++j) {
                    auto& value = field.value_at(j);
                    auto binary_field = tmpl->field_named(value.extended_name(scope));
                    auto value_reader = produce_read_call(&binary_field, &value, data);
                    m_type.binary_fields.emplace(binary_field.label(), value_reader);
                }
            }
        }
        else {
            for (auto i = 0; i < field.value_count(); ++i) {
                auto& value = field.value_at(i);
                auto binary_field = tmpl->field_named(value.base_name());
                auto value_reader = produce_read_call(&binary_field, &value, data);
                m_type.binary_fields.emplace(binary_field.label(), value_reader);

                if (value.has_joined_values()) {
                    for (const auto& joined : value.joined_values()) {
                        binary_field = tmpl->field_named(joined.base_name());
                        value_reader = produce_read_call(&binary_field, &joined, data);
                        m_type.binary_fields.emplace(binary_field.label(), value_reader);
                    }
                }
            }
        }
    }
}

auto kdl::codegen::lua::exporter::prepare_template_read_calls(ast::symbol *resource) -> void
{
    auto tmpl = m_type_definition->binary_template();
    for (const auto& binary_field : tmpl->all_fields()) {
        auto it = m_type.binary_fields.find(binary_field.label());
        if (it == m_type.binary_fields.end()) {
            auto skip_length = static_cast<std::int64_t>(binary_field.skip_length());
            m_generator.call(m_generator.symbol("data"), m_api.skip, { m_generator.number(skip_length) });
            continue;
        }

        auto resource_member = m_generator.member(m_generator.private_symbol(m_generator.camel_case(binary_field.label())), resource);
        if (binary_field.is_list()) {
            m_generator.assign(resource_member, it->second);
        }
        else {
            m_generator.new_line();

            auto count = m_generator.symbol(m_generator.camel_case(binary_field.label() + "Count"));
            m_generator.local_assign(count, it->second);

            auto idx = m_generator.symbol("idx");
            auto userdata = reinterpret_cast<ast::userdata_literal *>(m_generator.userdata_literal());
            m_generator.assign(resource_member, userdata);

            m_generator.for_loop(idx, m_generator.number(1), count);
            m_generator.begin_block();
            {
                auto element = m_generator.subscript(resource_member, idx);
                auto element_userdata = reinterpret_cast<ast::userdata_literal *>(m_generator.userdata_literal());
                m_generator.assign(element, element_userdata);
                m_generator.push(element_userdata->block());
                for (auto& list_field : binary_field.list_fields()) {
                    auto it = m_type.binary_fields.find(list_field.label());
                    if (it == m_type.binary_fields.end()) {
                        throw std::runtime_error("Failed to find corresponding binary field specified whilst exporting Lua.");
                    }

                    auto field_name = list_field.label();
                    auto name_it = m_type.export_names.find(list_field.label());
                    if (name_it != m_type.export_names.end()) {
                        field_name = name_it->second;
                    }

                    m_generator.assign(m_generator.camel_case(field_name), m_generator.comma(it->second));
                }
                m_generator.pop();
            }
            m_generator.pop();
            m_generator.new_line();
        }
    }
}

auto kdl::codegen::lua::exporter::produce_template_property_mapping(ast::symbol *resource) -> void
{
    m_generator.new_line();
    for (auto& field : m_type_definition->all_fields()) {
        if (field.repeatable().enabled() && !field.repeatable().has_count_field()) {
            auto var = m_generator.private_symbol(m_generator.camel_case(field.name()));
            auto userdata = reinterpret_cast<ast::userdata_literal *>(m_generator.userdata_literal());
            m_generator.assign(m_generator.member(var, resource), userdata);

            m_generator.push(userdata->block());
            for (std::int64_t i = field.repeatable().lower_bound(); i <= field.repeatable().upper_bound(); ++i) {
                auto scope = m_scope->subscope();
                scope.add_variable("FieldNumber", i);

                auto subscript = m_generator.subscript(nullptr, m_generator.number(i));
                ast::node *element_value = nullptr;

                if (field.value_count() == 1) {
                    auto value_name = field.value_at(0).extended_name(scope);
                    element_value = m_generator.member(m_generator.private_symbol(m_generator.camel_case(value_name)), resource);
                }
                else {
                    auto element_userdata = reinterpret_cast<ast::userdata_literal *>(m_generator.userdata_literal());
                    element_value = element_userdata;
                    m_generator.push(element_userdata->block());
                    {
                        for (const auto& value : field.values()) {
                            auto var_name = build_field_name(&value, i);
                            auto value_name = value.extended_name(scope);
                            auto value_var = m_generator.member(m_generator.private_symbol(m_generator.camel_case(value_name)), resource);
                            m_generator.assign(var_name, m_generator.comma(value_var));
                        }
                    }
                    m_generator.pop();
                }

                m_generator.assign(subscript, m_generator.comma(element_value));
            }
            m_generator.pop();
        }
        else if (field.value_count() > 1 && !field.repeatable().enabled()) {
            auto element_userdata = reinterpret_cast<ast::userdata_literal *>(m_generator.userdata_literal());
            m_generator.push(element_userdata->block());
            {
                for (const auto& value : field.values()) {
                    auto value_var = m_generator.member(m_generator.private_symbol(m_generator.camel_case(value.base_name())), resource);
                    m_generator.assign(build_field_name(&value), m_generator.comma(value_var));
                }
            }
            m_generator.pop();
            auto var = m_generator.member(m_generator.private_symbol(m_generator.camel_case(field.name())), resource);
            m_generator.assign(var, element_userdata);
        }
        else if (field.value_count() == 1 && field.value_at(0).has_joined_values()) {
            auto element_userdata = reinterpret_cast<ast::userdata_literal *>(m_generator.userdata_literal());
            m_generator.push(element_userdata->block());
            {
                auto field_value = field.value_at(0);
                auto value_var = m_generator.member(m_generator.private_symbol(m_generator.camel_case(field_value.base_name())), resource);
                m_generator.assign(build_field_name(&field_value), m_generator.comma(value_var));

                for (const auto& joined : field_value.joined_values()) {
                    value_var = m_generator.member(m_generator.private_symbol(m_generator.camel_case(joined.base_name())), resource);
                    m_generator.assign(build_field_name(&joined), m_generator.comma(value_var));
                }
            }
            m_generator.pop();
            auto var = m_generator.member(m_generator.private_symbol(m_generator.camel_case(field.name())), resource);
            m_generator.assign(var, element_userdata);
        }
    }

    m_generator.new_line();
}

auto kdl::codegen::lua::exporter::produce_read_call(const resource::definition::binary_template::field *binary_field, const resource::definition::type::field_value *field_value, ast::symbol *data) -> ast::node *
{
    ast::node *value = nullptr;

    if (field_value->is_type_explicit()) {
        const auto& value_type = field_value->type();

        if (value_type.is_reference() && value_type.has_name()) {
            auto klass = m_generator.declare_class(value_type.name(), true);
            auto klass_type_code = m_generator.declare_static_function(true, m_generator.symbol("resourceTypeCode"), klass);
            value = m_generator.call(data, m_api.read_typed_reference, { m_generator.call(klass_type_code) });
        }
        else if (value_type.is_reference()) {
            value = m_generator.call(data, m_api.read_reference);
        }
        else if (value_type.has_name()) {
            if (value_type.name() == kdl::spec::types::color) {
                value = m_generator.call(data, m_api.read_color);
            }
            else if (
                value_type.name() == kdl::spec::types::file ||
                value_type.name() == kdl::spec::types::string
            ) {
                switch (binary_field->type().value()) {
                    case resource::definition::binary_template::type::PSTR: {
                        value = m_generator.call(data, m_api.read_pstr);
                        break;
                    }
                    case resource::definition::binary_template::type::CSTR: {
                        value = m_generator.call(data, m_api.read_cstr);
                        break;
                    }
                    case resource::definition::binary_template::type::Cnnn: {
                        value = m_generator.call(data, m_api.read_cstr_of_length, { m_generator.number(binary_field->type().size()) });
                        break;
                    }
                    default: {
                        throw std::runtime_error("");
                    }
                }
            }
            else if (
                value_type.name() == kdl::spec::types::image ||
                value_type.name() == kdl::spec::types::image_set ||
                value_type.name() == kdl::spec::types::sound ||
                value_type.name() == kdl::spec::types::data
            ) {

            }
            else if (
                value_type.name() == kdl::spec::types::bitmask ||
                value_type.name() == kdl::spec::types::range ||
                value_type.name() == kdl::spec::types::integer
            ) {
                switch (binary_field->type().value()) {
                    case resource::definition::binary_template::type::CHAR:
                    case resource::definition::binary_template::type::DBYT: {
                        value = m_generator.call(data, m_api.read_signed_byte);
                        break;
                    }
                    case resource::definition::binary_template::type::DWRD: {
                        value = m_generator.call(data, m_api.read_signed_short);
                        break;
                    }
                    case resource::definition::binary_template::type::DLNG: {
                        value = m_generator.call(data, m_api.read_signed_long);
                        break;
                    }
                    case resource::definition::binary_template::type::DQWD: {
                        value = m_generator.call(data, m_api.read_signed_quad);
                        break;
                    }
                    case resource::definition::binary_template::type::HBYT: {
                        value = m_generator.call(data, m_api.read_byte);
                        break;
                    }
                    case resource::definition::binary_template::type::HWRD: {
                        value = m_generator.call(data, m_api.read_short);
                        break;
                    }
                    case resource::definition::binary_template::type::HLNG: {
                        value = m_generator.call(data, m_api.read_long);
                        break;
                    }
                    case resource::definition::binary_template::type::HQWD: {
                        value = m_generator.call(data, m_api.read_quad);
                        break;
                    }
                    default: {
                        throw std::runtime_error("");
                    }
                }
            }
            else if (value_type.name() == kdl::spec::types::command_encoder) {
                value = m_generator.call(m_api.command_decoder_from, { data });
            }
        }
    }
    else {
        value = produce_read_call(binary_field, data);
    }

    return value;
}

auto kdl::codegen::lua::exporter::produce_read_call(const resource::definition::binary_template::field *binary_field, ast::symbol *data) -> ast::node *
{
    ast::node *value = nullptr;
    switch (binary_field->type().value()) {
        case resource::definition::binary_template::type::DBYT:
        case resource::definition::binary_template::type::CHAR: {
            value = m_generator.call(data, m_api.read_signed_byte);
            break;
        }
        case resource::definition::binary_template::type::OCNT:
        case resource::definition::binary_template::type::DWRD: {
            value = m_generator.call(data, m_api.read_signed_short);
            break;
        }
        case resource::definition::binary_template::type::DLNG: {
            value = m_generator.call(data, m_api.read_signed_long);
            break;
        }
        case resource::definition::binary_template::type::DQWD: {
            value = m_generator.call(data, m_api.read_signed_quad);
            break;
        }
        case resource::definition::binary_template::type::HBYT: {
            value = m_generator.call(data, m_api.read_byte);
            break;
        }
        case resource::definition::binary_template::type::HWRD: {
            value = m_generator.call(data, m_api.read_short);
            break;
        }
        case resource::definition::binary_template::type::HLNG: {
            value = m_generator.call(data, m_api.read_long);
            break;
        }
        case resource::definition::binary_template::type::HQWD: {
            value = m_generator.call(data, m_api.read_quad);
            break;
        }
        case resource::definition::binary_template::type::RECT: {
            value = m_generator.call(data, m_api.read_rect);
            break;
        }
        case resource::definition::binary_template::type::PSTR: {
            value = m_generator.call(data, m_api.read_pstr);
            break;
        }
        case resource::definition::binary_template::type::CSTR: {
            value = m_generator.call(data, m_api.read_cstr);
            break;
        }
        case resource::definition::binary_template::type::Cnnn: {
            value = m_generator.call(data, m_api.read_cstr_of_length, { m_generator.number(binary_field->type().size()) });
            break;
        }
        case resource::definition::binary_template::type::RSRC: {
            value = m_generator.call(data, m_api.read_reference);
            break;
        }
        case resource::definition::binary_template::type::HEXD: {
            // TODO: Implement this...
            // break;
        }
        case resource::definition::binary_template::type::NESTED: {
            // TODO: Implement this...
            // break;
        }
        default: {
            value = m_generator.nil();
            break;
        }
    }

    return value;
}

auto kdl::codegen::lua::exporter::produce_resource_reader_for_loop(ast::node *var, ast::symbol *data, ast::node *lower, ast::node *upper, const std::function<auto(ast::node *) -> void> &block) -> void
{
    auto idx = m_generator.symbol("idx");
    m_generator.for_loop(idx, lower, upper);
    m_generator.begin_block();
    {
        auto userdata = reinterpret_cast<ast::userdata_literal *>(m_generator.userdata_literal());
        m_generator.assign(m_generator.subscript(var, idx), userdata);
        m_generator.push(userdata->block());
        block(idx);
        m_generator.pop();
    }
    m_generator.end_block();
    m_generator.new_line();
}

auto kdl::codegen::lua::exporter::associated_explicit_type_binary_field(const resource::definition::binary_template::field *binary_field) -> const resource::definition::type::descriptor *
{
    for (auto& field : m_type_definition->all_fields()) {
        for (std::int64_t n = field.repeatable().lower_bound(); n <= field.repeatable().upper_bound(); ++n) {
            auto scope = m_scope->subscope();
            scope.add_variable("FieldNumber", n);
            for (const auto& value : field.values()) {
                auto name = value.extended_name(scope);
                auto bin_field = m_type_definition->binary_template()->field_named(name);
                if (bin_field.label() == binary_field->label()) {
                    return &value.type();
                }
            }
        }
    }
    return nullptr;
}

auto kdl::codegen::lua::exporter::produce_type_constants() -> void
{
    m_generator.add_comment("Constants");

    auto produce_constants_for_value = [&] (const resource::definition::type::field_value& value, std::int64_t lower_bound) {
        if (!value.has_symbols()) {
            return;
        }

        auto scope = m_scope->subscope();
        scope.add_variable("FieldNumber", lower_bound);
        auto binary_field = m_type_definition->binary_template()->field_named(value.extended_name(scope));

        auto constants_metadata = reinterpret_cast<ast::userdata_literal *>(m_generator.userdata_literal());
        m_generator.assign(m_generator.symbol(value.base_name()), m_generator.comma(constants_metadata));
        m_generator.push(constants_metadata->block());
        {
            for (const auto& symbol : value.symbols()) {
                auto symbol_name = symbol.first;
                auto symbol_value = symbol.second.value();

                ast::node *constant = m_generator.nil();
                if (value.is_type_explicit()) {
                    if (value.type().is_reference()) {
                        auto global = m_generator.call(m_api.namespace_global);
                        constant = m_generator.call(global, m_api.identified_resource, {
                            m_generator.number(symbol_value.integer_value<std::int64_t>())
                        });
                    }
                    else if (value.type().has_name()) {
                        if (value.type().name() == spec::types::color) {
                            constant = m_generator.call(m_api.color_klass_color_value, {
                                m_generator.number(symbol_value.integer_value<std::uint32_t>())
                            });
                        }
                        else if (
                            value.type().name() == spec::types::bitmask ||
                            value.type().name() == spec::types::range ||
                            value.type().name() == spec::types::integer
                        ) {
                            constant = m_generator.number(symbol_value.integer_value<std::int64_t>());
                        }
                        else if (
                            value.type().name() == spec::types::file ||
                            value.type().name() == spec::types::string
                        ) {
                            constant = m_generator.string(symbol_value.string_value());
                        }
                    }
                    else {
                        switch (binary_field.type().value()) {
                            case resource::definition::binary_template::type::DBYT:
                            case resource::definition::binary_template::type::DWRD:
                            case resource::definition::binary_template::type::DLNG:
                            case resource::definition::binary_template::type::DQWD:
                            case resource::definition::binary_template::type::HBYT:
                            case resource::definition::binary_template::type::HWRD:
                            case resource::definition::binary_template::type::HLNG:
                            case resource::definition::binary_template::type::HQWD:
                            case resource::definition::binary_template::type::OCNT:
                            case resource::definition::binary_template::type::CHAR: {
                                constant = m_generator.number(symbol_value.integer_value<std::int64_t>());
                                break;
                            }

                            case resource::definition::binary_template::type::PSTR:
                            case resource::definition::binary_template::type::CSTR:
                            case resource::definition::binary_template::type::Cnnn: {
                                constant = m_generator.string(symbol_value.string_value());
                                break;
                            }
                            default: {
                                break;
                            }
                        }
                    }
                }
                m_generator.assign(m_generator.symbol(symbol_name), m_generator.comma(constant));
            }
        }
        m_generator.pop();
    };

    auto userdata = reinterpret_cast<ast::userdata_literal *>(m_generator.userdata_literal());
    m_generator.assign(m_generator.member(m_generator.symbol("Constants"), m_type.klass_name), userdata);
    m_generator.push(userdata->block());
    {
        for (auto& field : m_type_definition->all_fields()) {
            for (const auto& value : field.values()) {
                produce_constants_for_value(value, field.repeatable().lower_bound());
                for (const auto& joined : value.joined_values()) {
                    produce_constants_for_value(joined, field.repeatable().lower_bound());
                }
            }
        }
    }
    m_generator.pop();
    m_generator.new_line();
}

auto kdl::codegen::lua::exporter::produce_type_properties() -> void
{
    m_generator.new_line();
    m_generator.add_comment("Properties");
    for (auto& field : m_type_definition->all_fields()) {
        auto name = m_generator.camel_case(field.name());
        auto symbol = name;
        if (field.repeatable().has_count_field()) {
            symbol = m_generator.camel_case(field.repeatable().count_field()->label());
        }

        auto property = m_generator.declare_property(m_type.klass, name, symbol);
        produce_property_getter(property);
        if (field.has_decorator(spec::decorators::setter)) {
            produce_property_setter(property);
        }
        m_generator.new_line();
    }
}

auto kdl::codegen::lua::exporter::produce_property_getter(ast::property_definition *property) -> void
{
    m_generator.synthesize_getter(property);
}

auto kdl::codegen::lua::exporter::produce_property_setter(ast::property_definition *property) -> void
{
    m_generator.synthesize_setter(property);
}

// MNARK: - Code Generator

auto kdl::codegen::lua::exporter::generate() -> std::string
{
    determine_export_names();
    produce_header();
    produce_class_boilerplate();
    produce_type_constants();
    produce_model_loader();
    produce_type_properties();
    return m_generator.generate();
}